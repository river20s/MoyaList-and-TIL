# 머클 트리(Merkle Tree) 

### 정의

각 노드가 그 아래에 있는 모든 [리프 노드](https://github.com/river20s/TIL/blob/main/Algorithms/%EB%A6%AC%ED%94%84.md)를 해시하는 [트리](https://github.com/river20s/TIL/blob/main/Algorithms/%ED%8A%B8%EB%A6%AC.md). 주로 이진 트리이다. 각 내부 노드가 자식 노드들을 [해시](https://github.com/river20s/TIL/blob/main/Algorithms/%ED%95%B4%EC%8B%B1(Hashing)%EC%9D%B4%EB%9E%80.md)한다.
각 리프는 자신이 나타내는 정보 블록의 해시를 가진다.
모든 리프 노드는 동일한 깊이에 위치하고 모든 노드는 가능한 한 왼쪽에 있음
가득 찬 트리(각 노드가 0개 또는 2개의 자식을 가진 이진 트리)에 리프를 추가하려면 기존 루트를 왼쪽 자식으로 둔 새 루트가 생긴다. 오른쪽 자식은 리프 수준까지 왼쪽 서브 트리로만 구성된, 퇴화된 트리이다. 해시 트리라고도 hash tree라고도 불린다. **머클 트리를 사용해 대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증(verification)할 수 있다.**

### 예시
> 키 공간이 1부터 12까지인 머클 트리를 만들어보자.

#### step 1.
키 공간을 버킷(bucket)으로 나눈다. 임의로 4 개 버킷으로 나누어보았다.
(그림 1)
#### step 2.
버킷에 포함된 각각의 키에 균등 분포 해시(uniform hash)함수를 적용하여 해시 값을 계산한다.
(그림 2)
#### step 3. 
버킷별로 해시 값을 계산한 후, 해당 해시 값을 레이블로 갖는 노드를 만든다.
(그림 3)
#### step 4. 
자식 노드의 레이블로부터 새로운 해시 값을 계산하여 이진 트리를 상향식으로 구성해나간다.
(그림 4)

이 두 머클 트리를 비교할 때는 먼저 루트 노드의 해시값을 비교한다. 루트 노드의 해시값이 일치하면 두 서버는 같은 데이터를 갖는 것이다. 그 값이 다른 경우에는 왼쪽 자식 노드의 해시 값을 비교하고, 그 다음으로 오른쪽 자식 노드의 해시 값을 비교한다. 이렇게 하면서 아래로 탐색해 나가면 다른 데이터를 갖는 버킷을 찾을 수 있으므로, 그 버킷들만 동기화 하면 된다.

머클 트리를 사용하면 동기화해야 하는 데이터의 양은 실제로 존재하는 차이의 크기에 비례할 뿐, 두 서버에 보관된 데이터의 총량과는 무관해진다. 하지만 실제로 쓰이는 시스템의 경우 버킷 하나의 크기가 꽤 크다. 예를 들어 10억(1B) 개의 키를 백만(1M) 개의 버킷으로 관리하면 하나의 버킷이 1000개의 키를 관리하게 된다.


